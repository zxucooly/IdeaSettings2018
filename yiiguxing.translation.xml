<application>
  <component name="AppStorage">
    <histories>
      <item value="Invoke factory processors registered as beans in the context." />
      <item value="Register bean processors that intercept bean creation." />
      <item value="Abstract Type Hierarchy Traversing Filter" />
      <item value="Generic Application Context" />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="canonical Name" />
      <item value="condition Evaluator" />
      <item value="temporary" />
      <item value="Interface for registries that hold bean definitions, for example RootBeanDefinition * and ChildBeanDefinition instances. Typically implemented by BeanFactories that * internally work with the AbstractBeanDefinition hierarchy. * * &lt;p&gt;This is the only interface in Spring's bean factory packages that encapsulates * &lt;i&gt;registration&lt;/i&gt; of bean definitions. The standard BeanFactory interfaces * only cover access to a &lt;i&gt;fully configured factory instance&lt;/i&gt;. * * &lt;p&gt;Spring's bean definition readers expect to work on an implementation of this * interface. Known implementors within the Spring core are DefaultListableBeanFactory * and GenericApplicationContext." />
      <item value="encapsulates" />
      <item value="Apply the given relative path to the given Java resource path, * assuming standard Java folder separation (i.e. &quot;/&quot; separators)." />
      <item value="Capable" />
      <item value="Environment Capable" />
      <item value="canonical" />
      <item value="// Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available..." />
      <item value="Initialize any placeholder property sources in the context environment." />
      <item value="Prepare this context for refreshing, setting its startup date and * active flag as well as performing any initialization of property sources." />
      <item value="Stub" />
      <item value="Mutable" />
      <item value="Generic Application Listener" />
      <item value="Determine whether the given listener supports the given event. * &lt;p&gt;The default implementation detects the {@link SmartApplicationListener} * and {@link GenericApplicationListener} interfaces. In case of a standard * {@link ApplicationListener}, a {@link GenericApplicationListenerAdapter} * will be used to introspect the generically declared type of the target listener." />
      <item value="detects" />
      <item value="Helper class that encapsulates a specific set of target listeners, * allowing for efficient retrieval of pre-filtered listeners. * &lt;p&gt;An instance of this helper gets cached per event type and source type." />
      <item value="retriever" />
      <item value="Explicitly remove target for a proxy, if registered already, // in order to avoid double invocations of the same listener." />
      <item value="default Retriever" />
      <item value="Retriever" />
      <item value="Explicitly" />
      <item value="Event published as early as conceivably possible as soon as a {@link SpringApplication} * has been started - before the {@link Environment} or {@link ApplicationContext} is * available, but after the {@link ApplicationListener}s have been registered. The source * of the event is the {@link SpringApplication} itself, but beware of using its internal * state too much at this early stage since it might be modified later in the lifecycle. *" />
      <item value="Resolve the single type argument of the given generic interface against * the given target class which is assumed to implement the generic interface * and possibly declare a concrete type for its type variable." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="30" />
        <entry key="ENGLISH" value="31" />
      </map>
    </option>
  </component>
</application>