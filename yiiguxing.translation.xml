<application>
  <component name="AppStorage">
    <histories>
      <item value="partial" />
      <item value="is Pre Flight Request" />
      <item value="No choice but to go through all mappings..." />
      <item value="but for the expected actual request based on the URL * path" />
      <item value="pre-flight" />
      <item value="potentially" />
      <item value="Matchable" />
      <item value="dispatching" />
      <item value="request" />
      <item value="Principal" />
      <item value="If such a callback is not supported by the * underlying runtime environment, the callback &lt;i&gt;must be ignored&lt;/i&gt; * and a corresponding warning should be logged." />
      <item value="respectively" />
      <item value="is performed" />
      <item value="publishing an event regardless of the outcome." />
      <item value="The actual event handling is performed by the abstract" />
      <item value="regardless of the outcome." />
      <item value="Mutable Property Values" />
      <item value="Request To View Name Translator" />
      <item value="special considerations apply for asynchronous * request processing. For more details see" />
      <item value="Intercept the execution of a handler. Called after HandlerMapping determined * an appropriate handler object" />
      <item value="latter" />
      <item value="repetitive" />
      <item value="granularity" />
      <item value="optionally accompanied" />
      <item value="The former is the default if no * HandlerMapping bean is registered in the application context." />
      <item value="although" />
      <item value="In case of FactoryBean, match object created by FactoryBean." />
      <item value="whether to initialize &lt;i&gt;lazy-init singletons&lt;/i&gt; and * &lt;i&gt;objects created by FactoryBeans&lt;/i&gt; (or by factory methods with a * &quot;factory-bean&quot; reference) for the type check. Note that FactoryBeans need to be * eagerly initialized to determine their type: So be aware that passing in &quot;true&quot; * for this flag will initialize FactoryBeans and &quot;factory-bean&quot; references. * @return a Map with the matching beans, containing the bean names as * keys and the corresponding bean instances as values * @throws BeansException if a bean could not be created" />
      <item value="the raw FactoryBean itself will be matched against the * type" />
      <item value="// Either the context is not a ConfigurableApplicationContext with refresh // support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here." />
      <item value="retrieve" />
      <item value="No context instance was injected at construction time -&gt; see if one // has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id" />
      <item value="// The context instance was injected without an explicit parent -&gt; // determine parent for root web application context, if any." />
      <item value="SPI" />
      <item value="explicit" />
      <item value="synthetic" />
      <item value="Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest." />
      <item value="between" />
      <item value="regular Post Processors" />
      <item value="Invoke factory processors registered as beans in the context." />
      <item value="Register bean processors that intercept bean creation." />
      <item value="Abstract Type Hierarchy Traversing Filter" />
      <item value="Generic Application Context" />
      <item value="Eagerly check singleton cache for manually registered singletons." />
      <item value="canonical Name" />
      <item value="condition Evaluator" />
      <item value="temporary" />
      <item value="Interface for registries that hold bean definitions, for example RootBeanDefinition * and ChildBeanDefinition instances. Typically implemented by BeanFactories that * internally work with the AbstractBeanDefinition hierarchy. * * &lt;p&gt;This is the only interface in Spring's bean factory packages that encapsulates * &lt;i&gt;registration&lt;/i&gt; of bean definitions. The standard BeanFactory interfaces * only cover access to a &lt;i&gt;fully configured factory instance&lt;/i&gt;. * * &lt;p&gt;Spring's bean definition readers expect to work on an implementation of this * interface. Known implementors within the Spring core are DefaultListableBeanFactory * and GenericApplicationContext." />
      <item value="encapsulates" />
      <item value="Apply the given relative path to the given Java resource path, * assuming standard Java folder separation (i.e. &quot;/&quot; separators)." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="68" />
        <entry key="ENGLISH" value="69" />
        <entry key="SLOVENIAN" value="1" />
      </map>
    </option>
  </component>
</application>